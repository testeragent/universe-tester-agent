/**
 * Watchdog - automatycznie restartuje agenta tester po błędzie
 *
 * Monitoruje plik tests-data.js i uruchamia ponownie agenta gdy:
 * - isRunning=true ale lastUpdate > 3 min (agent się zawiesił/błąd)
 *
 * NIE czyści sesji - agent kontynuuje gdzie skończył.
 *
 * Użycie:
 * node watchdog.js           - uruchom watchdog
 * node watchdog.js --once    - sprawdź raz i wyjdź
 *
 * Aby zatrzymać: Ctrl+C lub utwórz plik watchdog-stop.txt
 */

const fs = require('fs');
const path = require('path');
const { spawn, execSync } = require('child_process');

const MONITOR_FILE = path.join(__dirname, '..', 'monitor', 'tests-data.js');
const RESTART_FLAG = path.join(__dirname, '..', 'monitor', 'needs-restart.txt');
const STOP_FILE = path.join(__dirname, 'watchdog-stop.txt');
const CHECK_INTERVAL_MS = 30 * 1000; // Sprawdzaj co 30 sekund
const STALE_THRESHOLD_MS = 3 * 60 * 1000; // 3 minuty bez aktualizacji = agent martwy
const RESTART_DELAY_MS = 15 * 1000; // Odczekaj 15s przed restartem (daj czas na cleanup)

let restartCount = 0;
const MAX_RESTARTS = 5; // Max 5 restartów w jednej sesji watchdoga

function log(msg) {
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');
    console.log(`[${now}] ${msg}`);
}

function getTestData() {
    try {
        if (!fs.existsSync(MONITOR_FILE)) {
            return null;
        }

        const content = fs.readFileSync(MONITOR_FILE, 'utf8');
        const match = content.match(/var testData\s*=\s*(\{[\s\S]*\});?\s*$/);

        if (!match) return null;

        return JSON.parse(match[1]);
    } catch (e) {
        return null;
    }
}

function markAsRestarting(testData) {
    try {
        const now = new Date().toISOString().slice(0, 19);

        testData.lastUpdate = now;
        testData.agentStatus = {
            ...testData.agentStatus,
            currentAction: `Watchdog: Restart #${restartCount + 1} za ${RESTART_DELAY_MS/1000}s...`,
        };

        const newContent = `// Auto-generated by Test Monitor\nvar testData = ${JSON.stringify(testData, null, 2)};\n`;
        fs.writeFileSync(MONITOR_FILE, newContent, 'utf8');
    } catch (e) {
        log(`Błąd zapisu statusu: ${e.message}`);
    }
}

function restartAgent() {
    restartCount++;
    log(`Uruchamiam agenta (restart #${restartCount})...`);

    try {
        // Uruchom agenta w tle przez cmd
        // Używamy 'start' żeby nie blokować watchdoga
        const cmd = `start "Agent Tester" cmd /c "cd /d C:\\Users\\Dom && claude \\"Kontynuuję jako Agent Tester. Przeczytaj instrukcje z C:\\Users\\Dom\\.claude\\agents\\tester\\AGENT.md. WAŻNE: To jest restart po błędzie - NIE czyść dashboardu, kontynuuj gdzie skończyłeś!\\""`;

        execSync(cmd, {
            shell: 'cmd.exe',
            windowsHide: false
        });

        log('Agent uruchomiony w nowym oknie');

    } catch (e) {
        log(`Błąd uruchamiania agenta: ${e.message}`);
    }
}

function checkAndRestart() {
    // Sprawdź czy ma się zatrzymać
    if (fs.existsSync(STOP_FILE)) {
        log('Znaleziono watchdog-stop.txt - zatrzymuję');
        fs.unlinkSync(STOP_FILE);
        process.exit(0);
    }

    // Sprawdź limit restartów
    if (restartCount >= MAX_RESTARTS) {
        log(`Osiągnięto limit ${MAX_RESTARTS} restartów - zatrzymuję watchdog`);
        process.exit(1);
    }

    // PRIORYTET 1: Sprawdź flagę needs-restart.txt (błąd wewnętrzny)
    if (fs.existsSync(RESTART_FLAG)) {
        const flagContent = fs.readFileSync(RESTART_FLAG, 'utf8');
        log(`Znaleziono flagę restartu!`);
        log(`Powód: ${flagContent.split('\n')[1] || 'nieznany'}`);

        // Usuń flagę
        fs.unlinkSync(RESTART_FLAG);

        const testData = getTestData();
        if (testData) {
            markAsRestarting(testData);
        }

        // Odczekaj i uruchom
        log(`Restart za ${RESTART_DELAY_MS/1000}s...`);
        setTimeout(() => {
            restartAgent();
        }, RESTART_DELAY_MS);
        return;
    }

    const testData = getTestData();

    if (!testData) {
        log('Brak pliku tests-data.js - czekam...');
        return;
    }

    const agentStatus = testData.agentStatus || {};

    // Jeśli agent nie jest uruchomiony lub zakończył - nie restartuj
    if (!agentStatus.isRunning || agentStatus.finished) {
        log('Agent nie jest uruchomiony lub zakończył - OK');
        return;
    }

    // Sprawdź jak dawno była ostatnia aktualizacja
    const lastUpdate = testData.lastUpdate;
    if (!lastUpdate) {
        log('Brak lastUpdate - pomijam');
        return;
    }

    const lastUpdateTime = new Date(lastUpdate).getTime();
    const now = Date.now();
    const ageMs = now - lastUpdateTime;

    if (ageMs > STALE_THRESHOLD_MS) {
        const ageMinutes = Math.round(ageMs / 60000);
        log(`Agent nie odpowiada od ${ageMinutes} min - restartuję!`);

        // Oznacz że restartujemy
        markAsRestarting(testData);

        // Odczekaj i uruchom
        setTimeout(() => {
            restartAgent();
        }, RESTART_DELAY_MS);

    } else {
        const ageSec = Math.round(ageMs / 1000);
        log(`Agent aktywny (ostatnia aktualizacja ${ageSec}s temu)`);
    }
}

// Main
const args = process.argv.slice(2);
const onceMode = args.includes('--once');

log('=== WATCHDOG STARTED ===');
log(`Monitor: ${MONITOR_FILE}`);
log(`Threshold: ${STALE_THRESHOLD_MS / 1000}s`);
log(`Max restarts: ${MAX_RESTARTS}`);
log(`Mode: ${onceMode ? 'single check' : 'continuous'}`);

if (onceMode) {
    checkAndRestart();
    log('=== WATCHDOG DONE ===');
} else {
    // Pierwszy check natychmiast
    checkAndRestart();

    // Potem co interwał
    setInterval(checkAndRestart, CHECK_INTERVAL_MS);

    log(`Następne sprawdzenie za ${CHECK_INTERVAL_MS / 1000}s...`);
    log('Aby zatrzymać: Ctrl+C lub utwórz plik watchdog-stop.txt');
}
