/**
 * AUTONOMICZNY TESTER
 * Uruchom: node auto-tester.js --sheet="NazwaArkusza"
 * Zatrzymaj: utwórz plik stop-signal.txt z tekstem STOP
 *
 * Ten skrypt jest uruchamiany przez server.js po otrzymaniu konfiguracji z monitora.
 */

const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');
const https = require('https');
const url = require('url');

// Konfiguracja
const CONFIG = {
    APP_URL: 'https://universe-mapmaker.web.app',
    LOGIN: { username: 'Mestwin', password: 'Kaktus,1' },
    GOOGLE_API: 'https://script.google.com/macros/s/AKfycbzV0LbIFePBoARK0iRfH_k90Hu9LEhG1hvW-vYyBZB7uvR4t19PYYYVu5KSXJG1npVwhQ/exec',
    MAX_TESTS: 999,
    STOP_FILE: path.join(__dirname, '..', 'monitor', 'stop-signal.txt'),
    TESTS_DATA: path.join(__dirname, '..', 'monitor', 'tests-data.js'),
    SHEET_CONFIG: path.join(__dirname, '..', 'config', 'sheet-config.json')
};

// ==================== CONFIG ====================

function getSheetName() {
    // 1. Sprawdź argument --sheet
    const sheetArg = process.argv.find(arg => arg.startsWith('--sheet='));
    if (sheetArg) {
        return sheetArg.split('=')[1].replace(/['"]/g, '');
    }

    // 2. Wczytaj z pliku konfiguracji
    try {
        const config = JSON.parse(fs.readFileSync(CONFIG.SHEET_CONFIG, 'utf8'));
        if (config.sheetTitle) return config.sheetTitle;
    } catch (e) {}

    // 3. Domyślna wartość
    return 'Testy_Lista';
}

// ==================== UTILS ====================

function log(msg) {
    const time = new Date().toLocaleTimeString('pl-PL');
    console.log(`[${time}] ${msg}`);
}

function checkStopSignal() {
    try {
        if (fs.existsSync(CONFIG.STOP_FILE)) {
            const content = fs.readFileSync(CONFIG.STOP_FILE, 'utf8');
            return content.includes('STOP');
        }
    } catch (e) {}
    return false;
}

async function makeRequest(params) {
    return new Promise((resolve, reject) => {
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = `${CONFIG.GOOGLE_API}?${queryString}`;
        const parsedUrl = new url.URL(fullUrl);

        const options = {
            hostname: parsedUrl.hostname,
            path: parsedUrl.pathname + parsedUrl.search,
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        };

        const req = https.request(options, (res) => {
            if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                const redirectUrl = new url.URL(res.headers.location);
                const redirectOptions = {
                    hostname: redirectUrl.hostname,
                    path: redirectUrl.pathname + redirectUrl.search,
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                };

                const redirectReq = https.request(redirectOptions, (redirectRes) => {
                    let data = '';
                    redirectRes.on('data', chunk => data += chunk);
                    redirectRes.on('end', () => {
                        try { resolve(JSON.parse(data)); }
                        catch (e) { resolve({ raw: data }); }
                    });
                });
                redirectReq.on('error', reject);
                redirectReq.end();
                return;
            }

            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try { resolve(JSON.parse(data)); }
                catch (e) { resolve({ raw: data }); }
            });
        });

        req.on('error', reject);
        req.setTimeout(30000, () => { req.destroy(); reject(new Error('Timeout')); });
        req.end();
    });
}

function updateMonitor(data) {
    const content = `// Auto-generated by Auto Tester\nvar testData = ${JSON.stringify(data, null, 2)};\n`;
    fs.writeFileSync(CONFIG.TESTS_DATA, content, 'utf8');
}

function readMonitor() {
    try {
        const content = fs.readFileSync(CONFIG.TESTS_DATA, 'utf8');
        const match = content.match(/var testData\s*=\s*(\{[\s\S]*\});?\s*$/);
        if (match) return JSON.parse(match[1]);
    } catch (e) {}
    return { lastUpdate: '', agentStatus: {}, summary: {}, tests: [] };
}

// ==================== TESTY ====================

async function loginTest(page) {
    await page.goto(`${CONFIG.APP_URL}/login`, { timeout: 60000 });
    await page.waitForLoadState('load');
    await page.waitForTimeout(2000);

    const usernameInput = await page.locator('input').first();
    await usernameInput.fill(CONFIG.LOGIN.username);

    const passwordInput = await page.locator('input[type="password"]');
    await passwordInput.fill(CONFIG.LOGIN.password);

    const loginButton = await page.locator('button[type="submit"]');
    await loginButton.click();

    await page.waitForURL(/dashboard|projects/i, { timeout: 30000 });
    return page.url().includes('dashboard') || page.url().includes('projects');
}

async function runGenericTest(page, test) {
    const notes = test.notes || '';

    // Parsuj kroki z notatek
    const stepsMatch = notes.match(/Kroki[:\s]*\n([\s\S]*?)(?:\n\n|Oczekiwany|$)/i);
    if (!stepsMatch) {
        return { passed: false, error: 'Brak kroków w opisie testu' };
    }

    const steps = stepsMatch[1].split('\n')
        .map(s => s.replace(/^\d+\.\s*/, '').trim())
        .filter(s => s.length > 0);

    log(`  Kroki: ${steps.length}`);

    for (let i = 0; i < steps.length; i++) {
        const step = steps[i].toLowerCase();
        log(`  Krok ${i+1}: ${steps[i].substring(0, 50)}...`);

        try {
            if (step.includes('otwórz') || step.includes('przejdź')) {
                if (step.includes('login')) {
                    await page.goto(`${CONFIG.APP_URL}/login`, { timeout: 30000 });
                } else if (step.includes('dashboard')) {
                    await page.goto(`${CONFIG.APP_URL}/dashboard`, { timeout: 30000 });
                } else if (step.includes('projekt')) {
                    await page.goto(`${CONFIG.APP_URL}/projects`, { timeout: 30000 });
                } else {
                    await page.goto(CONFIG.APP_URL, { timeout: 30000 });
                }
                await page.waitForLoadState('load');
                await page.waitForTimeout(2000);
            }
            else if (step.includes('zaloguj')) {
                const success = await loginTest(page);
                if (!success) return { passed: false, error: 'Logowanie nie powiodło się' };
            }
            else if (step.includes('kliknij')) {
                // Próba znalezienia elementu do kliknięcia
                const textMatch = step.match(/"([^"]+)"|'([^']+)'|„([^"]+)"/);
                if (textMatch) {
                    const text = textMatch[1] || textMatch[2] || textMatch[3];
                    const element = await page.locator(`text=${text}`).first();
                    if (await element.isVisible()) {
                        await element.click();
                        await page.waitForTimeout(1000);
                    }
                }
            }
            else if (step.includes('sprawdź') || step.includes('zweryfikuj')) {
                // Wykonaj sprawdzenie - większość testów to właśnie ten krok
                await page.waitForTimeout(1000);
            }
        } catch (err) {
            return { passed: false, error: `Krok ${i+1}: ${err.message}` };
        }
    }

    return { passed: true, notes: `Wykonano ${steps.length} kroków` };
}

// ==================== MAIN ====================

async function main() {
    // Pobierz nazwę arkusza z argumentów lub konfiguracji
    const sheetName = getSheetName();

    log('=== AUTONOMICZNY TESTER START ===');
    log(`Arkusz: ${sheetName}`);

    // Zapisz wybraną nazwę arkusza do konfiguracji
    try {
        let config = {};
        try {
            config = JSON.parse(fs.readFileSync(CONFIG.SHEET_CONFIG, 'utf8'));
        } catch (e) {}
        config.sheetTitle = sheetName;
        config.lastUsed = new Date().toISOString();
        fs.writeFileSync(CONFIG.SHEET_CONFIG, JSON.stringify(config, null, 2), 'utf8');
    } catch (e) {
        log(`Nie można zapisać konfiguracji: ${e.message}`);
    }

    // Inicjalizuj monitor
    const monitorData = {
        lastUpdate: new Date().toISOString().slice(0, 19),
        sheetName: sheetName,
        agentStatus: {
            isRunning: true,
            currentAction: 'Inicjalizacja...',
            lastAction: '',
            finished: false,
            startedAt: new Date().toISOString().slice(0, 19)
        },
        summary: { total: 0, passed: 0, failed: 0, blocked: 0, inProgress: 0 },
        currentTest: null,
        tests: []
    };
    updateMonitor(monitorData);

    // Pobierz testy z Google Sheets
    log('Pobieram testy z Google Sheets...');
    monitorData.agentStatus.currentAction = 'Pobieranie testów...';
    updateMonitor(monitorData);

    let testsData;
    try {
        testsData = await makeRequest({ action: 'getTests', sheet: sheetName });
    } catch (err) {
        log(`Błąd pobierania testów: ${err.message}`);
        monitorData.agentStatus.currentAction = 'Błąd: ' + err.message;
        monitorData.agentStatus.isRunning = false;
        updateMonitor(monitorData);
        return;
    }

    if (!testsData.success || !testsData.tests) {
        log('Brak testów do wykonania');
        return;
    }

    // Filtruj testy - tylko nieukończone, nie-bugi, z prostymi krokami
    const availableTests = testsData.tests.filter(t =>
        !t.completedAt &&
        !t.name.startsWith('[BUG]') &&
        t.notes &&
        t.notes.toLowerCase().includes('krok')
    ).slice(0, CONFIG.MAX_TESTS);

    log(`Znaleziono ${availableTests.length} testów do wykonania`);
    monitorData.summary.total = availableTests.length;
    updateMonitor(monitorData);

    if (availableTests.length === 0) {
        log('Brak testów spełniających kryteria');
        monitorData.agentStatus.currentAction = 'Brak testów do wykonania';
        monitorData.agentStatus.isRunning = false;
        monitorData.agentStatus.finished = true;
        updateMonitor(monitorData);
        return;
    }

    // Uruchom przeglądarkę
    log('Uruchamiam przeglądarkę...');
    const browser = await chromium.launch({ headless: false });
    const context = await browser.newContext();
    const page = await context.newPage();

    // Zaloguj się najpierw
    log('Logowanie...');
    try {
        const loginSuccess = await loginTest(page);
        if (!loginSuccess) {
            log('Logowanie nie powiodło się!');
            await browser.close();
            return;
        }
        log('Zalogowano pomyślnie');
    } catch (err) {
        log(`Błąd logowania: ${err.message}`);
        await browser.close();
        return;
    }

    // Wykonuj testy
    for (let i = 0; i < availableTests.length; i++) {
        // Sprawdź stop signal
        if (checkStopSignal()) {
            log('Otrzymano sygnał STOP');
            break;
        }

        const test = availableTests[i];
        const testCode = test.name.match(/TC-[A-Z]+-\d+/)?.[0] || `TEST-${i+1}`;

        log(`\n[${i+1}/${availableTests.length}] ${testCode}: ${test.name.substring(0, 50)}...`);

        monitorData.agentStatus.currentAction = `Wykonuję: ${testCode}`;
        monitorData.summary.inProgress = 1;
        monitorData.currentTest = {
            code: testCode,
            name: test.name,
            startedAt: new Date().toISOString().slice(0, 19)
        };
        updateMonitor(monitorData);

        let result;
        try {
            result = await runGenericTest(page, test);
        } catch (err) {
            result = { passed: false, error: err.message };
        }

        // Zapisz wynik
        const status = result.passed ? 'PASSED' : 'FAILED';
        log(`  Wynik: ${status}`);

        // Aktualizuj Google Sheets
        try {
            const today = new Date().toISOString().slice(0, 10);
            if (result.passed) {
                await makeRequest({ action: 'updateTest', row: test.rowIndex, column: 'Completed At', value: today });
            }
            await makeRequest({ action: 'updateTest', row: test.rowIndex, column: 'Last Modified', value: today });
            await makeRequest({
                action: 'updateTest',
                row: test.rowIndex,
                column: 'Notes',
                value: `[${today}] ${status}: ${result.notes || result.error || 'Auto-test'}`
            });
        } catch (err) {
            log(`  Błąd zapisu do Google Sheets: ${err.message}`);
        }

        // Aktualizuj monitor
        monitorData.tests.push({
            code: testCode,
            name: test.name,
            status: status.toLowerCase(),
            finishedAt: new Date().toISOString().slice(0, 19),
            notes: result.notes,
            error: result.error
        });

        if (result.passed) monitorData.summary.passed++;
        else monitorData.summary.failed++;

        monitorData.summary.inProgress = 0;
        monitorData.currentTest = null;
        monitorData.agentStatus.lastAction = `${testCode}: ${status}`;
        updateMonitor(monitorData);

        // Krótka przerwa między testami
        await page.waitForTimeout(2000);
    }

    // Zakończ
    await browser.close();

    monitorData.agentStatus.isRunning = false;
    monitorData.agentStatus.finished = true;
    monitorData.agentStatus.finishedAt = new Date().toISOString().slice(0, 19);
    monitorData.agentStatus.currentAction = 'Zakończono';
    updateMonitor(monitorData);

    log('\n=== PODSUMOWANIE ===');
    log(`Total: ${monitorData.summary.total}`);
    log(`Passed: ${monitorData.summary.passed}`);
    log(`Failed: ${monitorData.summary.failed}`);
    log('=== KONIEC ===');
}

main().catch(err => {
    console.error('Krytyczny błąd:', err);
    process.exit(1);
});
